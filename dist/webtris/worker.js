"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTetrisWorker = function () {
    var workerBlob = new Blob(["\nonmessage = (function() {\n  \"use strict\"\n  \nvar TetrisEngineAction = {};\n(function (TetrisEngineAction) {\n    TetrisEngineAction[TetrisEngineAction[\"Play\"] = 0] = \"Play\";\n    TetrisEngineAction[TetrisEngineAction[\"PlayAgain\"] = 1] = \"PlayAgain\";\n    TetrisEngineAction[TetrisEngineAction[\"TogglePause\"] = 2] = \"TogglePause\";\n    TetrisEngineAction[TetrisEngineAction[\"SetLevel\"] = 3] = \"SetLevel\";\n    TetrisEngineAction[TetrisEngineAction[\"MoveDown\"] = 4] = \"MoveDown\";\n    TetrisEngineAction[TetrisEngineAction[\"MoveLeft\"] = 5] = \"MoveLeft\";\n    TetrisEngineAction[TetrisEngineAction[\"MoveRight\"] = 6] = \"MoveRight\";\n    TetrisEngineAction[TetrisEngineAction[\"RotateLeft\"] = 7] = \"RotateLeft\";\n    TetrisEngineAction[TetrisEngineAction[\"RotateRight\"] = 8] = \"RotateRight\";\n})(TetrisEngineAction);\nconst L = {\n    type: 'L',\n    shape: {\n        0: [\n            [1, 0],\n            [1, 0],\n            [1, 1]\n        ],\n        90: [\n            [0, 0, 1],\n            [1, 1, 1]\n        ],\n        180: [\n            [1, 1],\n            [0, 1],\n            [0, 1]\n        ],\n        270: [\n            [1, 1, 1],\n            [1, 0, 0]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 4,\n    color: 'magenta'\n};\nconst RL = {\n    type: 'RL',\n    shape: {\n        0: [\n            [0, 1],\n            [0, 1],\n            [1, 1]\n        ],\n        90: [\n            [1, 1, 1],\n            [0, 0, 1]\n        ],\n        180: [\n            [1, 1],\n            [1, 0],\n            [1, 0]\n        ],\n        270: [\n            [1, 0, 0],\n            [1, 1, 1]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 3,\n    color: 'red'\n};\nconst Zig = {\n    type: 'Zig',\n    shape: {\n        0: [\n            [1, 1, 0],\n            [0, 1, 1]\n        ],\n        90: [\n            [0, 1],\n            [1, 1],\n            [1, 0]\n        ],\n        180: [\n            [1, 1, 0],\n            [0, 1, 1]\n        ],\n        270: [\n            [0, 1],\n            [1, 1],\n            [1, 0]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 3,\n    color: 'cyan'\n};\nconst Zag = {\n    type: 'Zag',\n    shape: {\n        0: [\n            [0, 1, 1],\n            [1, 1, 0]\n        ],\n        90: [\n            [1, 0],\n            [1, 1],\n            [0, 1]\n        ],\n        180: [\n            [0, 1, 1],\n            [1, 1, 0]\n        ],\n        270: [\n            [1, 0],\n            [1, 1],\n            [0, 1]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 3,\n    color: 'blue'\n};\nconst Line = {\n    type: 'Line',\n    shape: {\n        0: [\n            [1],\n            [1],\n            [1],\n            [1]\n        ],\n        90: [\n            [1, 1, 1, 1]\n        ],\n        180: [\n            [1],\n            [1],\n            [1],\n            [1]\n        ],\n        270: [\n            [1, 1, 1, 1]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 4,\n    color: 'green'\n};\nconst Block = {\n    type: 'Block',\n    shape: {\n        0: [\n            [1, 1],\n            [1, 1]\n        ],\n        90: [\n            [1, 1],\n            [1, 1]\n        ],\n        180: [\n            [1, 1],\n            [1, 1]\n        ],\n        270: [\n            [1, 1],\n            [1, 1]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 3,\n    color: 'yellow'\n};\nconst T = {\n    type: 'T',\n    shape: {\n        0: [\n            [0, 1, 0],\n            [1, 1, 1]\n        ],\n        90: [\n            [0, 1],\n            [1, 1],\n            [0, 1]\n        ],\n        180: [\n            [1, 1, 1],\n            [0, 1, 0]\n        ],\n        270: [\n            [1, 0],\n            [1, 1],\n            [1, 0]\n        ]\n    },\n    rotation: 0,\n    rowPos: 0,\n    colPos: 4,\n    color: 'purple'\n};\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction getInitialStats() {\n    return {\n        T: {\n            type: 'T',\n            shape: T.shape['0'],\n            stats: 0,\n            color: T.color\n        },\n        L: {\n            type: 'L',\n            shape: L.shape['90'],\n            stats: 0,\n            color: L.color\n        },\n        RL: {\n            type: 'RL',\n            shape: RL.shape['90'],\n            stats: 0,\n            color: RL.color\n        },\n        Zig: {\n            type: 'Zig',\n            shape: Zig.shape['0'],\n            stats: 0,\n            color: Zig.color\n        },\n        Zag: {\n            type: 'Zag',\n            shape: Zag.shape['0'],\n            stats: 0,\n            color: Zag.color\n        },\n        Line: {\n            type: 'Line',\n            shape: Line.shape['90'],\n            stats: 0,\n            color: Line.color\n        },\n        Block: {\n            type: 'Block',\n            shape: Block.shape['0'],\n            stats: 0,\n            color: Block.color\n        }\n    };\n}\nfunction getInitialState() {\n    return {\n        board: generateCleanBoard(),\n        level: 0,\n        score: 0,\n        clearedLines: 0,\n        gameover: false,\n        gameInProgress: false,\n        nextShape: T.shape['0'],\n        nextColor: T.color,\n        stats: getInitialStats()\n    };\n}\nfunction generateCleanBoard() {\n    var board = [];\n    for (var i = 0; i < 22; ++i) {\n        board.push(Array(10).fill(0));\n    }\n    return board;\n}\nvar rotations = [0, 90, 180, 270];\nvar colors = [\n    'red',\n    'blue',\n    'green',\n    'cyan',\n    'magenta',\n    'yellow',\n    'purple'\n];\nvar MULTIPLIERS = {\n    0: 0,\n    1: 40,\n    2: 100,\n    3: 300,\n    4: 1200\n};\nfunction isColor(a) {\n    return typeof a === 'string' && colors.includes(a);\n}\nvar TetrisEngine = /** @class */ (function () {\n    function TetrisEngine(opts) {\n        var _this = this;\n        this.gamePieces = [\n            L, RL, Zig, Zag, Line, Block, T\n        ];\n        this.board = generateCleanBoard();\n        this.level = 0;\n        this.score = 0;\n        this.clearedLines = 0;\n        this.paused = false;\n        this.gameover = false;\n        this.gameInProgress = false;\n        this.stats = getInitialStats();\n        this.levelUpIn = 10;\n        this.loopSpeed = 1000;\n        this.play = function () {\n            _this.run();\n            _this.gameInProgress = true;\n        };\n        this.togglePause = function () {\n            if (!_this.gameInProgress) {\n                return;\n            }\n            if (_this.loopTimeout) {\n                clearTimeout(_this.loopTimeout);\n                _this.loopTimeout = undefined;\n                _this.paused = true;\n                // send out clean board on pause so users\n                // can't pause and plan\n                var data = _this.getState();\n                data.board = generateCleanBoard();\n                _this.updateRenderer(data);\n            }\n            else {\n                _this.paused = false;\n                _this.run();\n            }\n        };\n        this.setLevel = function (level) {\n            if (level === _this.level) {\n                return;\n            }\n            _this.level = level;\n            if (level === 0) {\n                _this.loopSpeed = 1000;\n            }\n            else {\n                _this.loopSpeed *= Math.pow(.75, level);\n            }\n            _this.levelUpIn = Math.min(100, (10 * _this.level + 10));\n        };\n        this.moveDown = function (accelerated) {\n            if (accelerated === void 0) { accelerated = true; }\n            if (_this.isHit()) {\n                return _this.renderNextPiece();\n            }\n            _this.modifyCurrentPiece('move-down');\n            if (accelerated) {\n                var shape = _this.currentPiece.shape[_this.currentPiece.rotation];\n                var height = shape.length;\n                // points for accelerated drop (height of piece plus drop increment)\n                _this.score += height + 1;\n            }\n        };\n        this.moveLeft = function () {\n            _this.modifyCurrentPiece('move-left');\n        };\n        this.moveRight = function () {\n            _this.modifyCurrentPiece('move-right');\n        };\n        this.rotateLeft = function () {\n            _this.modifyCurrentPiece('rotate-left');\n        };\n        this.rotateRight = function () {\n            _this.modifyCurrentPiece('rotate-right');\n        };\n        this.getState = function () {\n            return {\n                board: _this.board,\n                level: _this.level,\n                score: _this.score,\n                clearedLines: _this.clearedLines,\n                gameover: _this.gameover,\n                gameInProgress: _this.gameInProgress,\n                nextShape: _this.nextPiece.shape[_this.nextPiece.rotation],\n                nextColor: _this.nextPiece.color,\n                stats: _this.stats\n            };\n        };\n        this.run = function () {\n            if (_this.gameover) {\n                return;\n            }\n            _this.renderCurrentPiece();\n            var timeoutId = setTimeout(function () {\n                _this.moveDown(false);\n                _this.run();\n            }, _this.loopSpeed);\n            _this.loopTimeout = timeoutId;\n        };\n        this.getRandomPiece = function () {\n            var piece = __assign({}, _this.gamePieces[Math.floor(Math.random() * _this.gamePieces.length)]);\n            var rotation = (rotations[Math.floor(Math.random() * 4)]);\n            var color = colors[Math.floor(Math.random() * colors.length)];\n            piece.color = color;\n            piece.rotation = rotation;\n            return piece;\n        };\n        this.clearCurrentPiece = function () {\n            var board = _this.board.slice();\n            var piece = __assign({}, _this.currentPiece);\n            var rowPos = piece.rowPos;\n            var colPos = piece.colPos;\n            var shape = _this.currentPiece.shape[_this.currentPiece.rotation].slice();\n            for (var row = 0; row < shape.length; ++row) {\n                for (var col = 0; col < shape[0].length; ++col) {\n                    if (shape[row][col] !== 0) {\n                        board[row + rowPos][col + colPos] = 0;\n                    }\n                }\n            }\n            _this.board = board;\n        };\n        this.renderCurrentPiece = function () {\n            var board = _this.board.slice();\n            var piece = __assign({}, _this.currentPiece);\n            var rowPos = piece.rowPos;\n            var colPos = piece.colPos;\n            var rotation = _this.currentPiece.rotation;\n            var shape = _this.currentPiece.shape[rotation].slice();\n            loop1: for (var row = 0; row < shape.length; ++row) {\n                loop2: for (var col = 0; col < shape[0].length; ++col) {\n                    if (shape[row][col] === 1) {\n                        if (board[row + rowPos][col + colPos] !== 0) {\n                            board = _this.board;\n                            break loop1;\n                        }\n                        else {\n                            board[row + rowPos][col + colPos] = piece.color;\n                        }\n                    }\n                }\n            }\n            _this.board = board;\n            _this.updateRenderer(_this.getState());\n        };\n        this.renderNextPiece = function () {\n            _this.currentPiece = _this.nextPiece;\n            _this.stats[_this.currentPiece.type].stats++;\n            _this.nextPiece = _this.getRandomPiece();\n            _this.renderCurrentPiece();\n            if (_this.isGameOver()) {\n                _this.stopGame();\n            }\n        };\n        this.modifyCurrentPiece = function (modification) {\n            if (_this.paused) {\n                return;\n            }\n            if (_this.gameover) {\n                return;\n            }\n            if (!_this.gameInProgress) {\n                return;\n            }\n            _this.clearCurrentPiece();\n            switch (modification) {\n                case 'move-left':\n                    if (_this.canMoveLeft()) {\n                        _this.currentPiece.colPos--;\n                    }\n                    break;\n                case 'move-right':\n                    if (_this.canMoveRight()) {\n                        _this.currentPiece.colPos++;\n                    }\n                    break;\n                case 'move-down':\n                    _this.currentPiece.rowPos++;\n                    break;\n                case 'rotate-left':\n                case 'rotate-right': {\n                    var direction = modification.split('-')[1];\n                    var nextRotation = _this.getNextRotation(direction);\n                    if (_this.canRotate(nextRotation)) {\n                        _this.currentPiece.rotation = nextRotation;\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n            var wall = '';\n            if (_this.isAgainstWallOnLeft()) {\n                wall = 'left';\n            }\n            if (_this.isAgainstWallOnRight()) {\n                wall = 'right';\n            }\n            _this.adjustForWall(wall);\n            _this.renderCurrentPiece();\n        };\n        // make sure to clear current piece from board before calling this\n        // method or the rendering of the current piece will interfere.\n        this.canRotate = function (nextRotation) {\n            var board = _this.board;\n            var currRowPos = _this.currentPiece.rowPos;\n            var nextShape = _this.currentPiece.shape[nextRotation];\n            var nextColPos = _this.getColPosForRotation(nextRotation);\n            for (var i = 0; i < nextShape.length; ++i) {\n                for (var j = 0; j < nextShape[0].length; ++j) {\n                    var boardSlotFilled = isColor(board[currRowPos + i][nextColPos + j]);\n                    var pieceSlotFilled = nextShape[i][j] === 1;\n                    if (boardSlotFilled && pieceSlotFilled) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        this.getNextRotation = function (direction) {\n            var rotation = _this.currentPiece.rotation;\n            switch (direction) {\n                case 'left':\n                    rotation += 90;\n                    if (rotation === 360) {\n                        rotation = 0;\n                    }\n                    break;\n                case 'right':\n                    rotation -= 90;\n                    if (rotation < 0) {\n                        rotation = 270;\n                    }\n                    break;\n            }\n            return rotation;\n        };\n        this.getColPosForRotation = function (r) {\n            var shape = _this.currentPiece.shape[r];\n            var pieceWidth = shape[0].length;\n            if (_this.isAgainstWallOnRight(r)) {\n                return _this.board[0].length - pieceWidth;\n            }\n            if (_this.isAgainstWallOnLeft()) {\n                return 0;\n            }\n            return _this.currentPiece.colPos;\n        };\n        this.canMoveRight = function () {\n            var shape = _this.currentPiece.shape[_this.currentPiece.rotation];\n            var height = shape.length;\n            var xLen = shape[0].length;\n            var rightSide = _this.currentPiece.colPos + xLen;\n            var rowPos = _this.currentPiece.rowPos;\n            if (_this.isAgainstWallOnRight()) {\n                return false;\n            }\n            // check if it's blocked by another piece on the right\n            for (var i = 0; i < height; ++i) {\n                var blockToRight = isColor(_this.board[rowPos + i][rightSide]);\n                var shapeFilledInRightPos = shape[i][xLen - 1] === 1;\n                if (blockToRight && shapeFilledInRightPos) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        this.canMoveLeft = function () {\n            var shape = _this.currentPiece.shape[_this.currentPiece.rotation];\n            var height = shape.length;\n            var rowPos = _this.currentPiece.rowPos;\n            var colPos = _this.currentPiece.colPos;\n            if (_this.isAgainstWallOnLeft()) {\n                return false;\n            }\n            // check if it's blocked by another piece on the left\n            for (var i = 0; i < height; ++i) {\n                var blockToLeft = isColor(_this.board[rowPos + i][colPos - 1]);\n                var shapeFilledInLeftPos = shape[i][0] === 1;\n                if (blockToLeft && shapeFilledInLeftPos) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        this.isAgainstWallOnRight = function (rotation) {\n            if (rotation === void 0) { rotation = _this.currentPiece.rotation; }\n            var xLen = _this.currentPiece.shape[rotation][0].length;\n            var rightSide = _this.currentPiece.colPos + xLen;\n            return rightSide >= _this.board[0].length;\n        };\n        this.isAgainstWallOnLeft = function () {\n            return _this.currentPiece.colPos <= 0;\n        };\n        this.adjustForWall = function (wall) {\n            if (!wall) {\n                return;\n            }\n            var shape = _this.currentPiece.shape[_this.currentPiece.rotation];\n            var pieceWidth = shape[0].length;\n            switch (wall) {\n                case 'right':\n                    _this.currentPiece.colPos = _this.board[0].length - pieceWidth;\n                    break;\n                case 'left':\n                    _this.currentPiece.colPos = 0;\n                    break;\n            }\n        };\n        this.isGameOver = function () {\n            if (_this.isHit() && _this.currentPiece.rowPos <= 0) {\n                _this.gameover = true;\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        this.stopGame = function () {\n            if (_this.loopTimeout) {\n                clearTimeout(_this.loopTimeout);\n                _this.loopTimeout = undefined;\n            }\n            _this.gameover = true;\n            _this.gameInProgress = false;\n            _this.updateRenderer(_this.getState());\n        };\n        this.isHit = function () {\n            var piece = _this.currentPiece;\n            var rotation = piece.rotation;\n            var shape = piece.shape[rotation];\n            var rowPos = piece.rowPos;\n            var colPos = piece.colPos;\n            var bottomPos = piece.rowPos + shape.length - 1;\n            if (bottomPos === _this.board.length - 1) {\n                _this.clearLines();\n                return true;\n            }\n            for (var i = 0; i < shape.length; ++i) {\n                for (var j = 0; j < shape[0].length; ++j) {\n                    var shapeValue = shape[i][j];\n                    var nextRow = i + 1;\n                    var bockIsPartOfShape = shape[nextRow] && shape[nextRow][j];\n                    var boardRow = rowPos + i + 1;\n                    var boardCol = colPos + j;\n                    var boardValue = (_this.board[boardRow] && _this.board[boardRow][boardCol]);\n                    if (shapeValue && !bockIsPartOfShape && boardValue) {\n                        _this.clearLines();\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        this.computeScore = function (newlyClearedLines) {\n            _this.clearedLines += newlyClearedLines;\n            if (newlyClearedLines >= _this.levelUpIn) {\n                _this.level++;\n                _this.levelUpIn = 10 - (_this.levelUpIn - newlyClearedLines);\n                _this.loopSpeed *= .75;\n            }\n            else {\n                _this.levelUpIn -= newlyClearedLines;\n            }\n            var mult = MULTIPLIERS[newlyClearedLines];\n            _this.score += mult * (_this.level + 1);\n        };\n        this.clearLines = function () {\n            var numClearedLines = 0;\n            for (var i = 0; i < _this.board.length; ++i) {\n                var row = _this.board[i];\n                if (row.every(function (e) { return e !== 0; })) {\n                    ++numClearedLines;\n                    // @todo: show flash on row when clearing lines\n                    // this.board[i] = fullRowFlash;\n                    _this.board.splice(i, 1);\n                    _this.board.unshift(Array(10).fill(0));\n                }\n            }\n            _this.computeScore(numClearedLines);\n            _this.updateRenderer(_this.getState());\n        };\n        this.currentPiece = this.getRandomPiece();\n        this.updateRenderer = opts.onBoardUpdate;\n        this.stats[this.currentPiece.type].stats++;\n        this.nextPiece = this.getRandomPiece();\n        this.setLevel(opts.level || 0);\n        this.updateRenderer(this.getState());\n    }\n    TetrisEngine.PlayAgain = function (stateChangeHandler, level) {\n        var engine = new TetrisEngine({ onBoardUpdate: stateChangeHandler, level: level });\n        engine.play();\n        return engine;\n    };\n    return TetrisEngine;\n}());\n  function postNewState(state) {\n    postMessage(state);\n  }\n  let tetrisEngine = new TetrisEngine({\n    onBoardUpdate: postNewState,\n    level: 0\n  });\n  return (event) => {\n    const command = Array.isArray(event.data) ? event.data[0] : event.data;\n    switch (command) {\n      case TetrisEngineAction.Play:\n        return tetrisEngine.play();\n      case TetrisEngineAction.PlayAgain:\n        return tetrisEngine = (\n          TetrisEngine.PlayAgain(postNewState, event.data[1])\n        );\n      case TetrisEngineAction.TogglePause:\n        return tetrisEngine.togglePause();\n      case TetrisEngineAction.SetLevel:\n        return tetrisEngine.setLevel(event.data[1]);\n      case TetrisEngineAction.MoveDown:\n        return tetrisEngine.moveDown();\n      case TetrisEngineAction.MoveLeft:\n        return tetrisEngine.moveLeft();\n      case TetrisEngineAction.MoveRight:\n        return tetrisEngine.moveRight();\n      case TetrisEngineAction.RotateLeft:\n        return tetrisEngine.rotateLeft();\n      case TetrisEngineAction.RotateRight:\n        return tetrisEngine.rotateRight();\n    }\n  }\n})();"], { type: 'text/javascript' });
    return new Worker(window.URL.createObjectURL(workerBlob));
};
